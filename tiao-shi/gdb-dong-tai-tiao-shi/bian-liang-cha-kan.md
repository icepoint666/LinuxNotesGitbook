# 变量查看

GDB调试最大的目的之一就是走查代码，查看运行结果是否符合预期。既然如此，我们就不得不了解一些查看各种类型变量的方法，以帮助我们进一步定位问题。

在**查看变量之前**，需要**先启动调试并设置断点**，该部分内容在前面已经介绍过了。后面的内容都基于在某个位置已经断住。

这里想要查看变量的一个前提条件就是**程序需要运行起来**

本文辅助说明程序如下:  
testGdb.c

```c
//testGdb.c
#include<stdio.h>
#include<stdlib.h>
#include"testGdb.h"
int main(void)
{
    int a = 10; //整型
    int b[] = {1,2,3,5};  //数组
    char c[] = "hello,shouwang";//字符数组
    /*申请内存，失败时退出*/    
    int *d = (int*)malloc(a*sizeof(int));
    if(NULL == d)
    {
        printf("malloc error\n");
        return -1;
    }
    /*赋值*/
    for(int i=0; i < 10;i++)
    {
        d[i] = i;
    }
    free(d);
    d = NULL;
    float e = 8.5f;
    return 0;
}
```

testGdb.h

```cpp
int a = 11;
```

编译：

```bash
$ gcc -g -o testGdb testGdb.c
```

### **普通变量查看print**

#### **打印基本类型变量，数组，字符数组**

最常见的使用便是使用**print（可简写为p）打印变量内容**  
例如，打印**基本类型，数组，字符数组**等直接使用p 变量名即可：

```bash
(gdb)> p a
$1 = 10
(gdb)> p b
$2 = {1, 2, 3, 5}
(gdb)> p c
$3 = "hello,shouwang"
```

当然有时候，**多个函数或者多个文件会有同一个变量名**，这个时候可以在前面加上函数名或者文件名来区分：

```bash
(gdb)> p 'testGdb.h'::a
$1 = 11
(gdb)> p 'main'::b
$2 = {1, 2, 3, 5}
```

#### **打印指针指向内容**

如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如：

```text
(gdb)> p d
$1 = (int *) 0x602010
```

而如果**想要打印指针指向的内容，需要解引用**：

```bash
(gdb)> p *d
$2 = 0
(gdb)> p *d@10
$3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

从上面可以看到，仅仅使用\*只能打印第一个值，如果要打印多个值，后面跟上@并加上要打印的长度。  
或者@后面跟上变量值：

```bash
(gdb) p *d@a
$2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 
```

由于a的值为10，并且是作为整型指针数据长度，因此后面可以直接跟着a，也可以打印出所有内容。

另外值得一提的是**$可表示上一个变量**，而假设此时有一个链表linkNode，它有next成员代表下一个节点，则可使用下面方式不断打印链表内容：

```bash
(gdb)> p *linkNode
(这里显示linkNode节点内容)
(gdb)> p *$.next
(这里显示linkNode节点下一个节点的内容)
```

如果想要查看前面数组的内容，你可以将下标一个一个累加，还可以定义一个类似UNIX环境变量，例如：

```bash
(gdb)> set $index=0
(gdb)> p b[$index++]
$11 = 1
(gdb)> p b[$index++]
$12 = 2
(gdb)> p b[$index++]
$13 = 3
```

这样就不需要每次修改下标去打印啦。

### **按照特定格式打印变量**

对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：

* x 按十六进制格式显示变量。
* d 按十进制格式显示变量。
* u 按十六进制格式显示无符号整型。
* o 按八进制格式显示变量。
* t 按二进制格式显示变量。
* a 按十六进制格式显示变量。
* c 按字符格式显示变量。
* f 按浮点数格式显示变量。

还是以辅助程序来说明，正常方式打印字符数组c：

```bash
(gdb)> p c
$18 = "hello,shouwang"
```

但是如果我们要查看它的**十六进制格式打印**呢？

```bash
(gdb)> p/x c
$19 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 
  0x6e, 0x67, 0x0}
(gdb)
```

**想用这种方式查看浮点数的二进制格式**是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8（也就是1000）：

```bash
(gdb)> p e
$1 = 8.5
(gdb)> p/t e
$2 = 1000
```

那么就需要另外一种查看方式了。

### **查看内存内容**

examine\(简写为x\)可以用来查看内存地址中的值。语法如下：

```text
x/[n][f][u] addr
```

其中：

* n 表示要显示的内存单元数，默认值为1
* f 表示要打印的格式，前面已经提到了格式控制字符
* u 要打印的单元长度类型
* addr 内存地址

单元类型常见有如下：

* b 单字节
* h 半字，即双字节
* w 字，即四字节
* g 八字节

我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：

```bash
(gdb)> x/4tb &e
0x7fffffffdbd4:    00000000    00000000    00001000    01000001
```

可以看到，变量e的四个字节都以二进制的方式打印出来了。

### **自动监控变量变化watch**

有时候我们需要观察某个值或表达式，知道它什么时候发生变化了，这个时候我们可以借助watch命令。例如：

```bash
(gdb)> watch a
```

这个时候，让程序继续运行，如果a的值发生变化，则会打印相关内容，如：

```bash
Hardware watchpoint 2: a
Old value = 12
New value = 11
```

rwatch和awatch同样可以设置观察点前者是当变量值被读时断住，后者是被读或者被改写时断住。

### **自动显示变量内容display**

假设我们**希望程序断住时，就显示某个变量的值**，可以使用display命令。

```bash
(gdb)> display e
1: e = 8.5
```

那么每次程序断住时，就会打印e的值。**要查看哪些变量被设置了display，可以使用：**

```bash
(gdb)>into display
Auto-display expressions now in effect:
Num Enb Expression
1:   y  b
2:   y  e
```

如果想要清除可以使用

```bash
(gdb)> delete display num #num为前面变量前的编号,不带num时清除所有。
```

或者去禁用：

```bash
(gdb)> disable display num  #num为前面变量前的编号，不带num时去使能所有
```

### **查看寄存器内容info**

```bash
(gdb)>info registers
rax            0x0    0
rbx            0x0    0
rcx            0x7ffff7dd1b00    140737351850752
rdx            0x0    0
rsi            0x7ffff7dd1b30    140737351850800
rdi            0xffffffff    4294967295
rbp            0x7fffffffdc10    0x7fffffffdc10
(内容过多未显示完全)
```

